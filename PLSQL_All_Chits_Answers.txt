Chit 2 – Borrower fine calculation (Control + Exception)
DECLARE v_roll borrower.rollin%TYPE; v_book borrower.nameofbook%TYPE; v_days NUMBER; v_fine NUMBER; v_status borrower.status%TYPE; v_date DATE; BEGIN v_roll := &rollno; v_book := '&nameofbook'; SELECT (SYSDATE - dateofissue), status INTO v_days, v_status FROM borrower WHERE rollin = v_roll AND nameofbook = v_book; IF v_days BETWEEN 15 AND 30 THEN v_fine := v_days * 5; ELSIF v_days > 30 THEN v_fine := v_days * 50; ELSE v_fine := 0; END IF; UPDATE borrower SET status = 'R' WHERE rollin = v_roll AND nameofbook = v_book; IF v_fine > 0 THEN INSERT INTO fine VALUES (v_roll, SYSDATE, v_fine); DBMS_OUTPUT.PUT_LINE('Fine recorded: Rs ' || v_fine); ELSE DBMS_OUTPUT.PUT_LINE('No fine applicable.'); END IF; EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('No record found for entered Roll No and Book.'); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM); END;

Chit 3 – Attendance Term Granted or Not
DECLARE v_roll stud.roll%TYPE; v_att stud.att%TYPE; BEGIN v_roll := &roll; SELECT att INTO v_att FROM stud WHERE roll = v_roll; IF v_att < 75 THEN UPDATE stud SET status = 'D' WHERE roll = v_roll; DBMS_OUTPUT.PUT_LINE('Term not granted'); ELSE UPDATE stud SET status = 'ND' WHERE roll = v_roll; DBMS_OUTPUT.PUT_LINE('Term granted'); END IF; EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('Student not found.'); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM); END;

Chit 5 – Merge N_RollCall into O_RollCall using Cursor
DECLARE CURSOR c1 IS SELECT roll_no, name FROM n_rollcall; v_roll n_rollcall.roll_no%TYPE; v_name n_rollcall.name%TYPE; v_count NUMBER; BEGIN OPEN c1; LOOP FETCH c1 INTO v_roll, v_name; EXIT WHEN c1%NOTFOUND; SELECT COUNT(*) INTO v_count FROM o_rollcall WHERE roll_no = v_roll; IF v_count = 0 THEN INSERT INTO o_rollcall VALUES (v_roll, v_name); DBMS_OUTPUT.PUT_LINE('Inserted Roll: ' || v_roll); ELSE DBMS_OUTPUT.PUT_LINE('Duplicate skipped Roll: ' || v_roll); END IF; END LOOP; CLOSE c1; EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM); END;

Chit 6 – Procedure proc_Grade for Student Categorization
CREATE OR REPLACE PROCEDURE proc_grade(p_name IN VARCHAR2, p_marks IN NUMBER) IS v_class VARCHAR2(20); BEGIN IF p_marks BETWEEN 990 AND 1500 THEN v_class := 'Distinction'; ELSIF p_marks BETWEEN 900 AND 989 THEN v_class := 'First Class'; ELSIF p_marks BETWEEN 825 AND 899 THEN v_class := 'Higher Second'; ELSE v_class := 'Fail'; END IF; INSERT INTO result VALUES (result_seq.NEXTVAL, p_name, v_class); END; / DECLARE v_name stud_marks.name%TYPE; v_marks stud_marks.total_marks%TYPE; BEGIN v_name := '&name'; SELECT total_marks INTO v_marks FROM stud_marks WHERE name = v_name; proc_grade(v_name, v_marks); DBMS_OUTPUT.PUT_LINE('Grade stored successfully'); EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('Student not found.'); END;

Chit 7 – Stored Function version of Grade Categorization
CREATE OR REPLACE FUNCTION func_grade(p_marks IN NUMBER) RETURN VARCHAR2 IS v_class VARCHAR2(20); BEGIN IF p_marks BETWEEN 990 AND 1500 THEN v_class := 'Distinction'; ELSIF p_marks BETWEEN 900 AND 989 THEN v_class := 'First Class'; ELSIF p_marks BETWEEN 825 AND 899 THEN v_class := 'Higher Second'; ELSE v_class := 'Fail'; END IF; RETURN v_class; END; / DECLARE v_name stud_marks.name%TYPE; v_marks stud_marks.total_marks%TYPE; v_result VARCHAR2(20); BEGIN v_name := '&name'; SELECT total_marks INTO v_marks FROM stud_marks WHERE name = v_name; v_result := func_grade(v_marks); INSERT INTO result VALUES (result_seq.NEXTVAL, v_name, v_result); DBMS_OUTPUT.PUT_LINE('Student ' || v_name || ' is in ' || v_result); EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('Student not found.'); END;

Chit 11 – Row Level BEFORE Trigger (Library Audit)
CREATE OR REPLACE TRIGGER trg_before_lib BEFORE UPDATE OR DELETE ON library FOR EACH ROW BEGIN IF UPDATING THEN INSERT INTO library_audit VALUES (:OLD.book_id, :OLD.book_name, 'Updated', SYSDATE); ELSIF DELETING THEN INSERT INTO library_audit VALUES (:OLD.book_id, :OLD.book_name, 'Deleted', SYSDATE); END IF; END;

Chit 12 – Row Level AFTER Trigger (Library Audit)
CREATE OR REPLACE TRIGGER trg_after_lib AFTER UPDATE OR DELETE ON library FOR EACH ROW BEGIN IF UPDATING THEN INSERT INTO library_audit VALUES (:OLD.book_id, :OLD.book_name, 'Updated after', SYSDATE); ELSIF DELETING THEN INSERT INTO library_audit VALUES (:OLD.book_id, :OLD.book_name, 'Deleted after', SYSDATE); END IF; END;